package sec01_finalmodifier.EX01_FinalModifier_1;

class A1{ // 선언과 동시에 값을 대입한 경우
	int a = 3;
	final int b = 5;
	A1(){
	}
}
class A2{ // 선언과 값의 대입을 분리한 경우
	int a;
	final int b;
	A2(){
		a = 3;
		b = 3;
	}
}
class A3{ // final 필드값을 대입한 후에는 추가 값 대입이 불가능함
	int a = 3;
	final int b = 5;
	A3(){
		a = 5;
		// b = 5; -> final 필드는 최초 선언된 이후 값을 대입할 수 없음. 상수
	}
}
class B{
	void bcd() {
		int a = 3;
		final int b =5;
		a = 7;
		// b - 9; -> final 지역 변수도 최초 선언 이후 값을 대입할 수 없음.
	}
}


public class FinalModifier_1 {

	public static void main(String[]args) {
		
		/* 10장 자바 제어자2
		   11.1 final 제어자
		   11.1.1 final 변수
		   
		   fianl 제어자는 필드, 지역 변수, 메서드, 클래스 앞에 위치할 수 있으며, 어디에 위치하느냐에 따라 의미가 다름. final 제어자는 변수를
		   선언할 때만 지정할 수 있으며, final 변수는 한 번 대입된 값을 수정할 수 없음. 즉 한 번 대입된 값이 최종 값이 되는 셈. 
		   상기 외부 클래스에는 이러한 final 클래스를 선언하는 여러 방법에 대한 코드가 작성되어 있음. 
		   
		   클래스 내 필드는 선언과 동시에 값을 대입(클래스 A1)할 수도 있고, 선언과 초기화를 분리(클래스 A2)해 작성할 수도 있음. 이때 final
		   필드의 초기화는 반드시 생성자에서 진행함. 세 번째는 필드를 선언할 때 초기화를 수행하고, 객체를 생성할 생성자에서 값을 변경(클래스 A3)
		   하는 예임. 이를 차례대로 살펴보면 클래스A1에서 필드 b가 final로 선언 돼 있음. 즉, 필드 b의 값은 이미 5로 초기화됐으므로 수정이
		   절대 불가능함. 따라서 다음처럼 A1 a1 = new A()와 같이 객체를 생성한 경우 a1.a의 값은 수정할 수 있지만, a1.b는 어떤 값으로도
		   수정이 불가능함. 생성자를 고치는 것 외에는 방법이 없음.
		   
		 */
		
		// 객체 생성
		
		A1 a1 = new A1();
		
		// 필드값 변경
		a1.a = 7;
		// a1.b = 1; // final 변수이므로 수정 불가능.
		
		// 객체 생성
		
		A2 a2 = new A2();
		
		// 필드값 변경
		
		a2.a = 7;
		// a2.b = 9; // final 변수이므로 수정 불가능.
		
		/* 클래스 A2도 이와 마찬가지. 클래스 A1과의 차이점은 final 필드도 선언과 값의 대입을 분리해 표기할 수 있다는 것. 다만 이렇게 선언과
		   값의 대입을 분리했을 때는 적어도 생성자에서는 값을 대입해야 함. 이는 final 필드가 일반 필드와 달리, 강제 초기화되지 않기 때문임.
		   재차 말하자면, final 필드는 일단 값이 입력되고 나면 절대로 값을 수정할 수 없다는 것. 따라서 클래스 A3은 클래스 자체에 오류가 있다는
		   것을 눈치챘을 것임. final 필드 b는 선언과 동시에 이미 초기화 됨. 따라서 생성자라 하더라도 더 이상 값은 변경할 수 없음. 다음 예제와
		   같이 지역 변수 앞에 final이 붙을 때도 개념은 같음. 클래스 B 내에서 bcd() 메서드에서 정의한 지역 변수 b는 final로 선언되어
		   있으므로 값을 수정 할 수 없음.
		   
		   final 제어자를 사용한 변수에 원래 있던 값을 그대로 또 대입한 경우
		   
		   final 제어자를 사용한 필드나 지역 변수에 일단 값이 대입되면 절대 변경할 수 없음. 더 정확히는 일단 값이 대입된 후 값을 입력하는
		   행위 자체가 불가능함. 즉, 다음 예와 같이 이전에 저장된 값과 동일한 값을 대입해도 오류가 발생한다는 것. 매우 고집스럽군.
		   
		 */
		
		System.out.println(a2.b); // a2.b = 3
		// a2.b = 3; // 같은 값을 다시 넣어도 오류가 발생함.
		
		/* 이러한 final 객체는 메모리 영역에서도 다른 점이 있음. 먼저 클래스 A를 정의한 경우엔 heap 영역에 A 객체를 생성하고, 객체 안에
		   필드 멤버들을 포함하게 됨. 이때 fnial 변수는 그 값을 그대로 복사해서 fnial 영역에 집어 넣음. 이러한 final 영역은 상수들이
		   머무르는 영역이기 때문에 이를 상수 영역이라고도 부름. 지역 변수들의 경우에도 비슷한 수순을 거침. 클래스 B의 bcd() 메서드가 heap
		   영역에 생성되고 지역 변수들이 stack 영역에 생성된 후에, fianl 변수는 상수final 영역에 그 값을 복사해서 넣음.
		   
		   이러한 final 변수는 자신의 값을 복사하는 고유의 성질을 활용해 많이 사용됨. 보통 메서드 내에서 생성된 지역 변수는 메서드가 종료되면
		   함께 증발하지만, 이벤트를 처리하다 보면 메모리에서 사라진 그 변수가 나중에 필요한 경우가 있음. 그래서 한 번 생성하면 사라지지 않는
		   영역인 상수 영역에 그 값은 존치하는 것. 이벤트 처리는 몰라도 '어떤 필요에 따라 복사본을 하나 만들어 놓음으로써 원본이 삭제된 이후에도
		   그 값을 활용할 수 잇도록 하는 것이 final 변수(필드, 지역변수)의 기능이라고 생각하면 됨.
		
		 */
		
	}
	
}
