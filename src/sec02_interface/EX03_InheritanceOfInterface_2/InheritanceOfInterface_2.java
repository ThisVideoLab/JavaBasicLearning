package sec02_interface.EX03_InheritanceOfInterface_2;

interface A{
	public abstract void abc();
}

interface B{
	void bcd(); // 컴파일러가 자동으로 public absratct를 추가해줌.
}

class C implements A {
	public void abc() {
		// 메서드 내용
	}
}

public class InheritanceOfInterface_2 {

	public static void main(String[]args) {
		
		/* 여기서 잠시 상속할 때 사용되는 extends와 implements 키워드를 정리하고 넘어가자. 클래스와 인터페이스 간의 상속 조합은 
		   외부 클래스와 같이 4가지로 나올 수 있음.
		   
		   클래스 extends 클래스
		   인터페이스 extends 인터페이스
		   클래스 implements 인터페이스
		   인터페이스 extends / implements 클래스
		   
		   
		   동종끼리는 extends 확장이며, implement 구현이라고 이해할 수 있음. 먼저 클래스가 클래스를 상속할 때는 extend, 클래스가
		   인터페이스를 상속할 때는 implements를 사용함. 앞에서 미완성 메서드를 완성하는 것을 구현하기 implements라고 했는데, 인터페이스
		   내부의 모든 메서드는 추상 메서드이므로 자식 클래스는 온전히 이들 추상 메서드를 구현해야 하기 때문임. 따라서 '클래스 A가 인터페이스 B를
		   상속했음.'라는 표현은 종종 '클래스 A가 인터페이스 B를 구현했다'로 표현되기도 함.
		   인터페이스가 인터페이스를 상속할때는 extends를 사용함. 인터페이스의 내부에는 완성된 메서드가 들어갈 수 없으므로 구현할 수 없는 것.
		   마지막으로 인터페잇느느 내부에 추상 메서드만 포함할 수 있으므로 만일 인터페이스가 클래스를 상속한다면 상속과 동시에 오류가 발생할 것임.
		   다시 클래스가 인터페이스를 상속하는 때로 돌아가 보자. 다음처럼 인터페이스를 상속하면 클래스는 상속과 동시에 문법적 오류가 발생하게 됨.
		   
		  intercafe A {
		      public abstract void abc();
		  }
		  
		  class B implements A{ // 오류 발생 
		  
		  }
		  
		  이는 인터페이스 내부의 미완성 메서드가 클래스 내부에 포함되기 때문임. 클래스 B는 일반 클래스로 정의되어 있으므로 내부에는 완성된 메서드만
		  포함돼야 함. 따라서 자식 클래스는 반드시 다음처럼 미완성 메서드를 완성시켜 줘야 문법적 오류를 피할 수 있음.
		  
		  class B implements A{  
		     void abc(){ // A를 구현하는 과정에서 미완성의 추상 메서드 abc()를 함께 들여왔으므로, 이를 구체적으로 완성하기 위한 메서드
		     } // 하지만 여전히 문제는 접근 지정자가 컴파일러에서 자동으로 default를 잡으므로 접근 지정자 에러가 발생한다는 것.
		  }
		  
		  자식 클래스에서는 부모 인터페이스의 추상 메서드를 완서앻ㅆ는데도 오류가 발생함. 그 이유는 바로 '접근 지정자'때문임. 오버라이딩을 수행할 때
		  접근 지정자는 반드시 부모 메서드의 지정 접근자보다 접근 범위가 같거나 커야 한다고 학습함. 인터페이스는 모든 필드와 메서드가 public으로
		  강제되므로 사실상 모든 자식 클래스의 구현 메서드는 public으로만 가능한 것. 하지만 앞의 예시에서는 접근 지정자를 표기하지 않아서
		  default 접근 지정자로 지정됐으므로 오류가 발생하는 것임. 인터페이스 내 필드와 메서드의 제어자를 생략하고 사용할 때 자주 범하는 실수이므로
		  항상 주의할 것.
		  
		 */
		
		
	}
	
}
