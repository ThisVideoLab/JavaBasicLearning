package sec01_operator_1.EX03_ShiftOperator;

public class EX03_ShiftOperator {

	public static void main(String[]args) {
	
		/* 3.2.3 시프트 연산자
		 
		 시프트shift 연산자는 비트의 위치를 좌우로 이동하는 연산으로, 산술 시프트 (<<, >>)와 논리 시프트(>>>)가 있음.
		 산술 시프트는 부호 비트는 유지하면서 나머지 비트를 왼쪽(<<) 또는 오른쪽(>>)으로 이동하는 연산자임.
		 
		 << 연산을 수행하면 부호 비트를 제외한 나머지 전체 비트가 왼쪽으로 이동하므로 1bit 이동할 때마다 x2의 효과가 있음. 
		 
		 5 = 0000..00101 << 2 (왼쪽으로 2회 시프트 수행)
		   = 0000..10100 = 20 (왼쪽으로 2칸 밀고 빈칸에는 부호비트 0으로 채워 넣기) 
		 왼쪽 시프트 2회 수행 결과 5 -> 20 (왼쪽 시프트 1회 당 2배로 증가함을 확인)
		 
		 >> 연산을 수행하면 부호 비트를 제외한 나머지 전체 비트가 오른쪽으로 이동하므로 1bit 이동할 때마다 ÷2의 효과가 있음. 
		 
		 5 = 0000..00101 >> 2 (오른쪽으로 2회 시프트 수행)
		   = 0000..00001 = 1 (오른쪽으로 2칸 밀고 빈칸에는 부호비트 0으로 채워 넣기) 
		 오른쪽 시프트 2회 수행 결과 5 -> 1 (오른쪽 시프트를 수행할 경우 1회당 1/2의 감소 효과가 있어야 하지만, 밀려 삭제되는 비트 때문에
		                              원래의 값에 1/2배를 한 것과는 다른 결과를 보일 수 있음)
		                              
		 -14 = 1111..0001 >> 2 (오른쪽으로 2회 시프트 수행)
		     = 1111..1100.0 = -3.5 (음수의 산술 시프트 연산 시에 소수점 자리는 올림, 다만 음수를 읽을때 -1을 추가하는 것은 해당 없음) 
		 오른쪽 시프트 2회 수행 결과 -16 -> -4 ( -3.5 이지만 올림으로 인해 -4로 연산) 
		                              
		 -16 = 1111..01111 >> 2 (오른쪽으로 2회 시프트 수행)
		     = 1111..11011 = -4 (오른쪽으로 2칸 밀고 빈칸에는 부호비트 1으로 채워 넣기) 
		 오른쪽 시프트 2회 수행 결과 -16 -> -4 ( 소수점 자리가 없으므로 별도의 보정 없음) 
		 
		 논리 시프트 
		 
		 논리 시프트logical right shift는 부호 비트를 포함해 전체 비트를 오른쪽으로 이동 시키는 연산. 빈칸은 모두 0으로 채움.
		 이러한 특성 때문에, 양수는 계속 양수로 남지만, 음수의 경우는 부호 비트를 옮기고 0으로 채워버려 양수로 변하게 됨.
		 
		 이러한 특징으로 인해서 논리 시프트는 전체 비트 중에서 특정 순서에 있는 비트의 값이 0인지 1인지를 체크할 때 용이하게 사용함.
		 핸드폰 전화 알람을 예로 들어보자. 핸드폰 전화 알람에는 보통 (소리, 화면, 진동) 이렇게 3가지의 경우가 있다. 사용자는
		 이러한 상태를 임의로 조정할 수 있으며, 순서대로 각 기능이 활성화 된 경우에는 1, 비활성화 된 경우에는 0으로 비트가 주어진다.
		 이럴 경우에 만약 소리만 켜 놓았다면 전화알람의 현재 전체 비트 상태는 100이 될 것이다. 이 상태에서 전화 알람의 활성/비활성을
		 체크하기 위해 100인 상태에서 2칸을 우측으로 논리 시프트를 하면 001이 되고, 이에 대해 AND(&) 연산자를 활용하여 체크하면
		 핸드폰의 알람 상태 값을 연산할 수 있다. 쉽게 말하자면 원하는 칸 만큼 숫자를 땡겨와서 눈 앞에 놓고 그 값의 0/1 여부를 연산하는 것.
		 
		 그렇기 때문에 이미 존재하는 자리마다의 값을 체크하는 용도이므로, 사실상 왼쪽 논리 시프트라는 연산자는 없는 것이다. 왼쪽 논리 시프트로
		 밀어내면 무조건 0이기 때문에 의미가 없기 때문이다. 
		 
		 여기서 한가지 사족으로, 100 전체를 읽더라도 전화알람의 소리만 켜져있고, 화면, 진동은 꺼져 있는 상태임을 알수도 있기에 논리 시프트가
		 다소 번거로운 방법이 아닐가란 생각도 든다. 그러나 전체 비트의 자리수가 길고, 다른 자리에 있는 특정 비트의 값만을 연산하고 싶은 경우엔
		 이러한 논리 시프트를 통한 파악이 부하가 덜 걸리는 방식이 아닐까하는 생각을 가져본다. 
		 
		 2진수를 16진수로 바꾸는 쉬운 방법
		 
		 2진수를 4자리마다 끊어서 읽어버릇하면 2진수를 쉽게 16 진수로 변환할 수 있음. 가령
		 
		 0b00111000 = 112이라는 2진수를 16진수로 변환한다면 0b를 제거 한 후에 4자리씩 끊어읽은 후에 그 값을 16진수의 n번째 자리에 넣음.
		 
		   0011 / 1000
		 = 3	/ 8	 
		 = 0x38
		 
		 이러한 식으로 끊어 읽기를 체득하면 쉽게 2진수를 16진수로 바꿀 수 있음. 마찬가지로 8진수에 대해 해본다면

		   111 / 000
		 =  7  /  0	 
		 = 070
		 
		 */
	
	}
	
}
