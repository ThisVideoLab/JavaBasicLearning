package sec01_inheritanceplymorphism.EX01_Inheritance;

class DeliveryFood {
	String name;
	int phoneNumber;
	void pickup() {}
	void delivery() {}
}
class Chicken extends DeliveryFood {
	int chickenRank;
	void coupon(){System.out.println("쿠폰이 발급되었습니다.");}
}
class Pizza extends DeliveryFood {
	int pizzaRank;
	void mileage(){System.out.println("마일리지가 적립되었습니다.");}
}

public class Inheritance {
	
	public static void main(String[]args) {
		
		/* 10장 클래스의 상속과 다형성
		   
		   10.1 클래스의 상속의 개념과 문법적 특징
		   
		   10.1.1 상속의 개념
		   
		   클래스의 상속은 부모 클래스의 멤버를 내려 받아 자식 클래스 내부에 포함시키는 자바의 문법 요소로, 이를 이해하기 위해서는 데이터에 대한
		   필드와 메서드에 대한 공통점과 차이점에 대한 이해를 겸비해야 함. 가령 배달 음식을 예로 들자면, 치킨과 피자가 있는데, 배달 조건을 
		   필드로, 배달 방식을 메서드로 구분해서 분류해보자. 이 둘은 모두 무료 배달에, 30분 이내 배달 보장의 공통점을 가지며, 각각 만오천원 이상,
		   이만원 이상의 최소 주문 금액이 존재함. 이럴 경우에 둘의 공통점은 배달 요금과 예상 도착 시간이고, 차이점은 최소 주문 금액이 됨.
		   그리고 메서드인 배달 방식은 직접 포장, 라이더 배달이 공통적으로 있고, 치킨은 한집 배달만 가능하며, 피자는 묶음 배달만 가능함.
		   이럴 경우에 각 멤버 종류별로 공통점을 묶어서 부모 클래스를 만들고, 자식 클래스에서 이를 상속받는다면, 메뉴가 백개 천개가 늘어나더라도
		   공통 멤버를 내려받아 쓰기 때문에 효율성이 엄청나게 증가하게 됨. 그 후에 자식 클래스에서 각 클래스마다 있는 차이점만을 추가하게 되면
		   자식 클래스를 효율적으로 구현할 수 있게 되는 장점이 있음. 뿐만 아니라 범주화를 통해 자료 검색 및 관리에도 굉장한 이점을 지님.
		   
		   UML과 그 범주에 대한 이해
		   
		   시스템을 모델로 표현해 주는 대표적 모델링 언어인 UML(unified modeling language)로 상속을 표시할 때는 화살표를 부모클래스
		   방향으로 향하게 그리게 됨. 보통 상속이 부모에서 자식으로 향하는 것과는 반대되는 방향인데, 이는 범주화의 과정에서 바라보면 좀 더
		   명확하게 이해가 됨. 부모 클래스는 더 넓은 범위를 아우르고, 자식 클래스는 더 세밀한 범위에 국한되므로, 더 넓은 범주의 부모 클래스를
		   구분하기 위해 부모 클래스로 화살표 방향을 그리는 것임. 언제나 그렇듯 이것은 약속이므로 이해와 암기를 병행해야 함.
		   
		   10.1.2 상속의 장점
		   
		   앞에서 언급한 상속의 이점을 구체적으로 표현하면, 첫 번째는 상속을 통한 코드의 중복성 제거가 있음. 즉 자식 클래스들의 공통적인 성분을
		   뽑아 부모 클래스에서 한 번만 정의했더니 코드가 간결해진 것. 두 번째 장점은 클래스의 다형적 표현이 가능하다는 점. 역시 치킨과 피자로
		   설명을 해보자.
		   '피자는 피자다'와 '치킨은 치킨이다'는 모두 옳은 표현임. 마찬가치로 '피자는 배달 음식이다'와 '치킨은 배달 음식이다'는 옳은 표현임.
		   이렇게 하나의 대상을 여러가지 속성으로 표현할 수 있는 특성을 다형성이라고 이름. 그러나 그러나 '배달음식은 피자다'와 '배달음식은
		   치킨이다'는 틀린 표현이 됨. 이처럼 반대 방향으로의 다형적 표현은 성립하지 않음. 이것이 상속을 표기할 때 왜 화살표가 부모 클래스를
		   향하는지에 대한 논리적인 이유임. 
		   지금까지의 내용을 정리하자면, 상속으로 얻을 수 있는 장점은 코드의 중복성을 제거할 수 있고, 다형적 표현을 할 수 있다는 것. 사실
		   코드의 중복성 제거로 얻을 수 있는 장점은 그리 크지 않음. 실제 개발 과정에서 코드 중복을 해결하기 위해선 상속보다 간단한 코드들을
		   그냥 각각의 클래스에 넣어 작성하는 것이 빠르고 효율적일 때가 많기 때문임.
		   반면 다형적 표현은 상속의 큰 장점임. 다형적 표현이 코딩에 실질적으로 어떠한 도움이 될까? 가령 사과, 포도, 키위 클래스를 만들고
		   각각의 객체를 2개, 2개, 3개씩 만들어서 배열로 관리하고자 함. 배열은 같은 자료형만 저장할 수 있으므로 어쩔 수 없이 3개의 배열
		   자료형을 따로 만들어서 관리해야 함. 만약 새로운 과일을 추가하려면 역시 새로운 자료형을 1개 추가해 관리해야 함.
		   
		   3개의 서로 다른 과일 배열 자료형
		   
		   사과[] apple = {new 사과(), new 사과()};
		   포도[] grape = {new 포도(), new 포도()};
		   키위[] kiwki = {new 키위(), new 키위()};
		   
		   하지만 사과, 포도, 키위는 모두 과일임. 따라서 '과일'이라는 부모 클래스를 만들어 각각에게 상속시키면 다형적 표현을 할 수 있게됨.
		   즉 다음과 같은 표현이 가능하다는 것.
		   
		   과일 fruit1 = new 사과() // 사과는 과일이다.
		   과일 fruit2 = new 포도() // 포도는 과일이다.
		   과일 fruit3 = new 키위() // 키위는 과일이다.
		   
		   따라서 각각의 과일로 생성한 객체를 모두 과일이라 부를 수 있게 되므로, 모든 객체를 과일 배열 하나로 관리할 수 있게 됨.
		   그렇게 되면 각각의 과일을 배열로 관리가 가능해짐.
		   
		   1개의 배열 자료형으로 여러 과일 객체를 저장
		   
		   과일[] fruits = [new 사과(), new 사과(), new 포도(), new 포도(), new 키위(), new 키위()}
		   
		   10.1.3 상속 문법
		   
		   클래스를 상속할 때는 extends 키워드를 사용하며, '자식 클래스명 extends 부모 클래스명'으로 표기함. 다만 부모 클래스를
		   2개 이상 지니는 다중 상속은 불가능함. 자바가 이를 허용하지 않는 이유는 여러 부모 클래스 내에 동일한 이름을 지닌 필드 멤버가
		   존재할 경우에 모호성이 발생한다는 것.
		   
		   가령 부모 클래스 A의 data 필드의 값은 3이고, 부모 클래스 B의 data 필드의 값은 4인 경우에, A와 B는 각각 독립적이므로
		   문제가 되지 않음. 그러나 상속을 받게 되면 data 필드의 값도 내려 받게 되는데 3이 적용될지 4가 적용될지가 모호하다는 것임.
		   그렇기 때문에 다중 상속을 허용하지 않음.
		   
		 */
		
		/*- 실습 - 클래스의 상속과 사용할 수 있는 멤버*/ System.out.println("*- 실습 - 클래스의 상속과 사용할 수 있는 멤버*");
		
		// DeliveryFood 객체 생성 // 부모 클래스 자체의 객체 생성 가능
		
		DeliveryFood d = new DeliveryFood();
		
		d.name = "다판다 배달음식";
		d.phoneNumber = 0211112222;
		d.pickup();
		d.delivery();
		
		// chicken 생성 // 자식 클래스의 객체 생성 가능
		
		Chicken c = new Chicken();
		
		c.name = "가산치킨";
		c.phoneNumber = 0233334444;
		c.pickup();
		c.delivery();
		
		c.chickenRank = 1; // 자식 클래스 Chicken에서 추가로 정의한 멤버
		c.coupon(); // 자식 클래스 Chicken에서 추가로 정의한 멤버
		
		// pizza 객체 생성
		
		Pizza p = new Pizza();
		
		p.name = "가산피자";
		p.phoneNumber = 0255556666;
		p.pickup();
		p.delivery();
		
		p.pizzaRank = 2; // 자식 클래스 pizza에서 추가로 정의한 멤버
		p.mileage(); // 자식 클래스 pizza에서 추가로 정의한 멤버
		
	}

}
