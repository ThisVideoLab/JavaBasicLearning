package sec03_methodoverriding.EX01_MethodOverriding_1;

class A{
	void print() {
		System.out.println("A 클래스");
	}
	
}

class B extends A{
	void print() {
		System.out.println("오버라이딩: B클래스");
	}
	
}

public class MethodOverriding_1 {

	public static void main(String[]args) {
		
		/* 10.3.1 메서드 오버라이딩의 개념과 동작
		   
		   메서드오버라이딩은 부모 클래스에게 상속받은 메서드와 동일한 이름의 메서드를 재정의하는 것. 즉 부모의 메서드를 자신이 만든 메서드로
		   덮어쓰는 개념임. 마치 우리가 동일한 위치에 동일한 파일을 저장하려고 덮어쓰기를 하는 것과 같은 원리임. 이유는 간단함. 대부분의 기능을
		   부모 클래스로부터 받는 것이 가능하지만 수행을 담당하는 메서드가 해당 자식 클래스에게 맞지 않아 교정하는 것. 튜닝이라고 생각하면 됨.
		   오버라이딩이 수행되기 위해서는 다음 2가지 조건을 만족해야 함.
		   
		   1. 부모 클래스의 메서드와 시그니처 및 리턴 타입이 동일해야 함.
		   2. 부모 클래스의 메서드보다 접근 지정자의 범위가 넓거나 같아야 함.
		   
		   먼저 부모 클래스의 메서드와 시그니처(메서드명, 입력매개변수의 타입과 개수)뿐 아니라 리턴 타입까지 완벽하게 일치해야 함. 두 번째 조건은
		   오버라이딩하려는 부모의 메서드보다 같거나 넓은 범위의 접근 지정자를 가져야 함. 다음 예를 살펴보자.
		   
		   클래스 A 내부에는 pirnt() 메서드를 포함하고 있으며, 클래스 B는 클래스 A를 상속받은 후 print() 메서드를 다시 재정의함으로써
		   오버라이딩을 실행함.
		   
		   class A{
				void print() {
					System.out.println("A 클래스");
				}
				
			}
			
			class B extends A{
				void print() {
					System.out.println("오버라이딩: B클래스");
				}
				
			}
		    
		    여기서 만약 A aa = new A()와 같이 객체를 생성한다면, 스태틱 영역에서 A() 생성자를 사용해, 힙 메모리에 객체가 생성되고,
		    스택 메모리에 생성된 참조 변수 aa가 힙 메모리에 생성된 aa의 A 객체를 가리킴. aa의 A 객체 내에선 print() 메서드가 있지만,
		    객체 내의 메서드는 위치값만을 저장함. 실제 print() 메서드는 스태틱 영역 내 메서드 영역에 저장되어 있게 됨. 
		      
		    <앞선 내용을 상기시키는 스태틱 영역 내 세부 영역 및 구성 요소>
			
			클래스 정보(Class Information)**:  클래스 이름, 부모 클래스 이름, 메서드 정보, 인터페이스 정보 등이 포함.
			런타임 상수 풀(Runtime Constant Pool): 컴파일 타임에 상수로 결정된 값들 (문자열 리터럴, 상수 표현식 결과 등)과 메서드, 필드 참조 등이 저장.
			메서드 데이터(Method Data): 메서드의 바이트코드, 메서드의 로컬 변수 테이블, 상수 풀 참조, 예외 테이블 등이 저장.
			메서드 영역(Method Area): 클래스 변수 (static 변수)와 메서드 코드가 저장.
			
			추가로 B bb = new B()와 같이 객체를 생성한다면, 스태틱 영역에서 B() 생성자를 사용해야 하고, 이를 위해 먼저 부모 클래스인
			객체 A를 생성해야 하므로 먼저 A() 생성자를 호출함. 그를 위해 먼저 A 객체 내의 print() 메서드가 메서드 영역에 생성 됨.
			이후 생성된 A 객체의 메서드들을 내포하는 형태의 B 객체가 생성 됨. 만약 A 객체 밖의 범위에 A객체의 메서드와 이름이 같은 메서드가
			존재한다면, B의 메서드는 A 객체의 메서드를 오버라이딩함. 그 결과 메서드 영역의 print()는 이미 B의 메서드로 오버라이딩이
			된 상태이므로, B의 메서드를 실행함.  

   			오버라이딩은 덮어쓰기와 똑같은 개념인가?
   			
   			개념을 설명하기 위해 우리에게 친숙한 윈도우 파일 시스템의 덮어쓰기를 끌어와 설명했지만, 기존 파일을 제거하고 새로운 파일을 덮어
   			씌우는 개념과는 거리가 있음. 오버라이딩이라는 말처럼, 조건이 만족하는 상황에서 다른 메서드를 올라타서 자신이 그 메서드인 양 행동하는
   			것이기에 끼어들어 대신 행세함 정도로 정리함이 적당함.
   			
   			동일한 필드나 메서드가 여럿 있는 경우는 무엇부터 실행하는가?
   			
   			객체 내에 동일한 필드 또는 동일한 메서드가 있는 경우에는 참조 변수가 가리키는 객체의 바깥쪽으로부터 안쪽 방향으로 들어가면서 만나는
   			첫번째 멤버가 실행됨. 이 말인즉슨 참조 변수를 가려 사용하면 특정 위치에 있는 메서드를 호출해서 사용할 수 있다는 것임.
   			
   			< A ab = new B()의 오버라이딩 : 중요 >
   			
   			오버라이딩에서 가장 중요한 개념이면서도 가장 혼동하는 주제 중 하나인 부모 클래스의 타입으로 자식 객체를 생성하는 것을 알아보자.
			
			1. 객체 생성 시작 (힙 영역): 
			   `new B();`는 힙 영역에 클래스 B의 인스턴스를 생성.
			   
			2. 부모 클래스 초기화 (힙 영역):
			   클래스 B의 생성자가 호출되기 전에, 힙 영역에서 클래스 A의 생성자가 호출되어 A의 객체를 초기화.
			   A 클래스의 생성자가 완료된 후, B 클래스의 생성자가 실행.
			
			3. 메서드 영역 로드 (메서드 영역):
			   클래스 A의 `print()` 메서드는 메서드 영역에 로드.
			   클래스 B의 `print()` 메서드도 메서드 영역에 로드.
			
			4. 객체 참조 (스택 영역):
			   생성된 B 객체는 스택 영역의 A 타입 참조 변수 `ab`에 할당.
			   이 참조 변수 `ab`는 힙 영역에 있는 B 타입 객체를 가리킴.
			
			5. 메서드 호출 (메서드 영역):
			   `ab.print();`를 호출하면, 실제 런타임 시점에서 메서드 영역에 로드된 B 객체의 `print()` 메서드가 호출.
			   이는 오버라이딩과 다형성(polymorphism)에 의해 이루어짐.
			   
			그렇다면 B bb = new B()와의 차이는 무엇인가? 일단 bb는 참조 변수가 힙 영역에 있는 B 타입의 객체를 가리키게 되므로,
			A 객체를 내포한 B 객체 전체를 사용한다는 것. 그러므로 A 클래스와 B 클래스의 모든 기능을 사용 가능함. 
			그러나 A ab = new B()의 경우는 A 객체를 내포한 B 객체에서 내포된 A 객체만을 가리키게 됨. 물론 A 내부의 print() 메서드는
			생성 과정에서 이미 오버라이딩이 되어서 B의 print()를 사용하게 되겠지만 나머지 내부 멤버를 A 생성자의 인터페이스만을 사용한다는
			차이점이 있음. 결과적으론 A 타입 형태의 클래스에 B의 메서드만을 오버라이딩해서 쓰고 싶을 때 선택 가능한 옵션이라는 것.
			이런 제한과 기능의 추가는 보안, 코드 작성의 효율성 런타임 시 발생하는 부하의 관점에서 이점을 취할 수 있는 방법임. 
		   
		 */
		
		/*- 실습 - A타입 / A 생성자*/ System.out.println("*- 실습 - A타입 / A 생성자*");
		
		// A 타입 / A 생성자
		System.out.println();
		
		A aa = new A();
		aa.print();
		
		// B 타입 / B 생성자
		System.out.println();
		
		B bb = new B();
		bb.print();
		
		// A 타입 / B 생성자
		System.out.println();
		
		A ab = new B();
		ab.print();
		
	}
	
}
