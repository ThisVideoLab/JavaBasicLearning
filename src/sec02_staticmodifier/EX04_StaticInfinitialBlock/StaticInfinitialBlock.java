package sec02_staticmodifier.EX04_StaticInfinitialBlock;

class A{
	int a;
	static int b;
	static {
		b =5; // 정적 필드의 초기화는 static{} 내에서 수행함
		System.out.println("클래스 A가 로딩됐습니다.");
	}
	A() {
		a = 3; // 인스턴스 필드 초기화는 일반적으로 생성자에서 수행함.
	}
}

public class StaticInfinitialBlock {
	
	public static void main(String[]args) {
		
		/* 9.2.4 정적 초기화 블럭
		   
		   일반적으로 인스턴스 필드의 초기화는 객체가 만들어지는 시점에서 이뤄짐. 즉, 객체가 생성자에서 만들어지므로 생성자 내에서 인스턴스
		   필드를 초기화하는 것이 일반적임. 그러나 정적 필드는 객체의 생성 이전에도 사용할 수 있어야 하므로 생성자가 호출되지 않은 상태에서도
		   초기화가 가능해야 함. 고로 생성자에서는 필드 초기화가 불가능하다는 것. 그래서 정적 필드를 초기화하기 위한 문법을 별도로 제공하는데
		   이것이 정적 초기화 블록(static P{}임.
		   
		   정적 초기화 블록
		   static {
		      // 클래스가 메모리에 로딩될 때 실행되는 내용
		   
		   }
		   
		   정적 초기화 블록은 클래스가 메모리에 로딩될 때 가장 먼저 실행되므로 여기에 정적 피륻의 초기화 코드를 넣어두면 클래스가 로딩되는
		   시점에 바로 초기화가 가능함. 다음 예를 살펴보자.
		   
		   static 초기화 블록
		   
		   class A {
		      int a;
		      static int b;
		      
		      static {
		         b = 5;
		         System.out.println("클래스가 로딩될 때 static block 실행");
		      }
		      A() {
		         a = 3;
		      }
		   }
		   
		   초기화 블록에서 정적 필드 b값으로 5를 넣어둠. 이정도의 초기화라면 static int b = 5와 같이 정적 필드를 선언할 때 바로 초기화하는
		   것이 효율적임. 복잡한 계산의 결과로 b값을 초기화해야 하는 경우에는 정적 초기화 블록 내에서 계산 코드를 작성한 뒤, 결과를 b에 대입함.
		   
		 */
		
		System.out.println(A.b);
		
		
		
		/*9.2.5 static main() 보이드
		   
		  지금까지 작성했던 public static void main(String[]args)도 정적 메서드임. 프로그램을 시작하면 가장 먼저 실행되는
		  main() 메서드는 왜 정적 메서드로 구성됐을까? 실제로 프로그램을 실행할 때 main() 메서드가 가장 먼저 실행되는 이유는 JVM이
		  main() 메서드를 실행시켜 주기 때문임. 그렇다면 JVM은 어떤 방식으로 main() 메서드를 실행할까? main() 메서드가 정적 메서드라
		  JVM은 '실행 클래스명.main()'을 호출하는 것만으로도 이 메서드를 실행하는 것임. 어찌 보면 프로그램을 실행할 때 JVM이 하는 역할은
		  '클래스명.main()'을 실행시켜주는 것 뿐임. 그래서 우리는 main() 메서드명도 바꿀 수 없음. 만일 main() 메서드가 인스턴스
		  메서드라면 아무리 JVM이라도 객체를 먼저 생성하고, 객체의 참조 변수를 이용해 main() 메서드를 호출해야만 했을 것임.
		  이를 정리하자면 JVM은 프로그램을 실행할 때 '실행 클래스명.main()'을 실행하므로 가장 먼저 실행되는 메서드인 main() 메서드를
		  정적 메서드로 구성한 것. 그렇게 되면 번잡하게 여러 과정 없이 훨씬 가볍게 main() 메서드를 호출 가능함.
		   
		 */
		
	}

}
