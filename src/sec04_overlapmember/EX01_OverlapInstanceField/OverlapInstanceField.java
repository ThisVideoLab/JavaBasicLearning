package sec04_overlapmember.EX01_OverlapInstanceField;

class A {
	int m = 3;
}

class B extends A {
	int m = 4;
}

public class OverlapInstanceField {

	public static void main(String[]args) {
		
		/* 10.4 인스턴스 필드와 정적 멤버의 중복
		   10.4.1 인스턴스 필드의 중복
		   
		   앞서 메서드 오버라이딩을 통해 개념을 이해했다면, 한가지 의문이 들기 마련임. 그렇다면 멤버는 오버라이딩이 안될 것인가? 또는 정적
		   메서드 오버라이딩은 불가능한가? 정답부터 말하면, 인스턴스 필드나 정적 멤버(정적 필드와 정적 메서드)는 자식 클래스에서 동일한 이름으로
		   정의해도 오버라이딩이 불가능함. 메모리 구조를 통해 이해해보도록 하자.
		   
		   10.4.1 인스턴스 필드의 중복
		   
		   먼저 인스턴스가 중복될 때를 살펴보자. 클래스 A에는 필드 m = 3이 있음. 클래스 B에는 A를 상속 받은 후 필드를 동일한 이름으로
		   선언하고 값을 4로 초기화 함. 이때 메서드 오버라이딩과 마찬가지로 3가지 메모리 동작을 살펴보자. 먼저 A a = new A()일 경우.
		   생성자 A를 사용해 힙 메모리에 A 객체를 새로이 생성함. 생성된 객체는 내부에 필드 m과 그 값인 3을 품고 있음. 그 후 참조 변수 a가
		   생성되어서 방금 생성된 A 객체의 위치값을 가리킴. 
		   비교를 위해 B b = new B()의 생성 과정을 살펴보자. 먼저 B() 생성자를 사용해서 힙 메모리에 B 객체를 만들기 시작하면 내포된
		   부모 클래스인 A 객체부터 생성됨. A 내부에 필드 m과 그 값인 3이 저장되어 객체 A가 생성되면, 이를 내포하는 B 객체가 생성되고
		   B 객체의 필드 m과 그 값인 4가 함께 담기게 됨. 이러한 구조를 통해 A의 필드 m과 B의 필드 m은 서로 다른 공간에 분리되어 저장됨을
		   알 수 있음. 고로 오버라이딩이 발생하지 않음. 그렇다면 각각의 필드는 어떤 방식으로 지정하여 호출 할 수 있을까? 
		   앞서 학습한 내용을 돌이켜보면, 참조 변수를 호출하는 경우엔 항상 지칭하는 객체의 테두리에서 안쪽으로 들어가면서 만나는 첫번째 값이
		   실행된다는 것. 
		   
		 */
		
		/*-실습- 인스턴스 필드의 중복*/ System.out.println("-실습- 인스턴스 필드의 중복");
		System.out.println();
		
		// 객체 생성
		
		A aa = new A();
		B bb = new B();
		A ab = new A();
		
		/*인스턴스 필드*/ System.out.println("인스턴스 필드");
		System.out.println();
		
		System.out.println(aa.m);
		System.out.println(bb.m);
		System.out.println(ab.m);
		
	}
	
}
