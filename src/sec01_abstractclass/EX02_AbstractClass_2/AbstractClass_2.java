package sec01_abstractclass.EX02_AbstractClass_2;

abstract class A{
	abstract void abc();
}

public class AbstractClass_2 {

	public static void main(String[]args) {
		
		/* 방법2) 익명 이너 클래스의 활용 
		   
		   AbstractClass_1에서 다룬 추상 클래스 A의 객체를 생성하는 두번째 방법은 익명 이너 클래스를 사용하는 것임. 이는 컴파일러가
		   내부적으로 추상 클래스를 상속해 메서드 오버라이딩을 수행한 클래스를 생성하고, 그 클래스로 객체를 생성하는 방법임. 이때 내부적으로
		   생성된 클래스명은 전혀 알 수 없으므로 개발자의 입장에서는 익명(이름 없는) 클래스가 되는 것임. 이너 클래스라는 이름이 붙은 이유는
		   나중에 알아볼 것. 먼저 익명 이너 클래스의 문법 구조는 다음과 같음.
		  
		   익명 이너 클래스
		   
		   클래스 참조 변수명 = new 생성자() {
		      // 추상 클래스에 포함된 추상 메서드 오버라이딩
		   }
		   
		   A a = new A() {
		      void abc() {
		         // ... -> 추상 메서드(미완성 메서드)의 오버라이딩(완성)
		      }
		   }
		   
		   이때 A()는 클래스 A의 생성자를 호출하는 것이 아니라 컴파일러가 클래스 A를 상속받아 abc() 메서드를 오버라이딩한 익명 클래스의
		   생성자를 호출한다는 것을 의미함. 이러한 2가지 객체 생성 방법은 객체를 생성할 수 없는 다른 객체지향 프로그래밍 요소인 인터페이스에도
		   그대로 적용되므로 꼭 이해해야 함.
		   		   
		 */
		
		// 객체 생성
		
		A a1 = new A() {
			void abc() { // 객체를 생성할 때마다 오버라이딩을 직접 입력해줘야 함.
				System.out.println("방법2. 익명 이너 클래스 방법으로 객체 생성");
			}
		};
		A a2 = new A() {
			void abc() { // 객체를 생성할 때마다 오버라이딩을 직접 입력해줘야 함.
				System.out.println("방법2. 익명 이너 클래스 방법으로 객체 생성");
			}
		};
		
		// 메서드 호출
		
		a1.abc();
		a2.abc();
		
		/* 익명 이너 클래스를 활용한 방법이 추가로 자식 클래스를 정의하지 않아도 되고, 코드도 상대적으로 간결하다는 장점이 있지만 매 객체 생성마다
		   오버라이딩을 한땀 한땀 해줘야하는 치명적인 단점이 있음. 일회용이 아닌 반복 사용이 필요한 경우에는 이러한 작성 방식이 오히려 단점이 됨. 
		   고로 딱 한번 만들 경우에 한해 익명 이너 클래스가 그 장점을 발휘할 수 있음.
		   
		 */
	}
	
}
